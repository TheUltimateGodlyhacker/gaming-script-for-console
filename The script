(function () {
  if (document.getElementById('customMenu')) {
    alert('Menu bestaat al!');
    return;
  }

  // CSS toevoegen
  const style = document.createElement('style');
  style.textContent = `
    #customMenu {
      position: fixed;
      top: 100px;
      left: 100px;
      width: 320px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      border-radius: 6px;
      font-family: sans-serif;
      z-index: 9999;
    }
    #customMenuHeader {
      background: #444;
      color: white;
      padding: 10px;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top-left-radius: 6px;
      border-top-right-radius: 6px;
    }
    #customMenuButtons {
      display: flex;
      flex-wrap: wrap;
      padding: 10px;
      gap: 5px;
    }
    .menuButton {
      flex: 1 0 30%;
      padding: 6px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .menuButton:hover {
      background: #0056b3;
    }
    #toggleMenu {
      background: #666;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
    }
    canvas#snakeCanvas {
      display: block;
      margin: 10px auto;
      border: 2px solid #333;
      background: #000;
    }
  `;
  document.head.appendChild(style);

  // Menu bouwen
  const menu = document.createElement('div');
  menu.id = 'customMenu';
  menu.innerHTML = `
    <div id="customMenuHeader">
      <span>Menu</span>
      <button id="toggleMenu">−</button>
    </div>
    <div id="customMenuButtons"></div>
  `;
  document.body.appendChild(menu);

  const buttonsContainer = document.getElementById('customMenuButtons');

  // 40 knoppen toevoegen
  for (let i = 1; i <= 50; i++) {
    const btn = document.createElement('button');
    btn.className = 'menuButton';
    btn.textContent = 'Knop ' + i;
    btn.id = 'menuBtn' + i;
    buttonsContainer.appendChild(btn);
  }

  // Minimaliseer/maximaliseer
  let isMinimized = false;
  document.getElementById('toggleMenu').onclick = function () {
    isMinimized = !isMinimized;
    buttonsContainer.style.display = isMinimized ? 'none' : 'flex';
    this.textContent = isMinimized ? '+' : '−';
  };

  // Sleepfunctionaliteit
  const header = document.getElementById('customMenuHeader');
  let isDragging = false, offsetX, offsetY;

  header.addEventListener('mousedown', function (e) {
    isDragging = true;
    offsetX = e.clientX - menu.offsetLeft;
    offsetY = e.clientY - menu.offsetTop;
  });

  document.addEventListener('mousemove', function (e) {
    if (isDragging) {
      menu.style.left = e.clientX - offsetX + 'px';
      menu.style.top = e.clientY - offsetY + 'px';
    }
  });

  document.addEventListener('mouseup', function () {
    isDragging = false;
  });
})();
(function () {
  const btn1 = document.getElementById('menuBtn1');
  if (!btn1) {
    alert("Menu nog niet geladen!");
    return;
  }

  btn1.onclick = function () {
    if (document.getElementById('snakeWindow')) return;

    const snakeWindow = document.createElement('div');
    snakeWindow.id = 'snakeWindow';
    snakeWindow.style.position = 'fixed';
    snakeWindow.style.top = '150px';
    snakeWindow.style.left = '150px';
    snakeWindow.style.width = '320px';
    snakeWindow.style.background = '#222';
    snakeWindow.style.border = '2px solid #333';
    snakeWindow.style.borderRadius = '8px';
    snakeWindow.style.boxShadow = '0 0 12px rgba(0,0,0,0.7)';
    snakeWindow.style.zIndex = '10000';
    snakeWindow.innerHTML = `
      <div id="snakeHeader" style="background:#111; color:white; padding:8px; cursor:move; border-top-left-radius:8px; border-top-right-radius:8px;">
        Snake Game <button id="closeSnake" style="float:right;background:#900;color:white;border:none;border-radius:4px;padding:2px 6px;cursor:pointer;">X</button>
      </div>
      <canvas id="snakeCanvas" width="300" height="300" style="display:block;margin:10px auto;border:2px solid #444;background:black;"></canvas>
    `;
    document.body.appendChild(snakeWindow);

    document.getElementById('closeSnake').onclick = () => {
      clearInterval(game);
      snakeWindow.remove();
    };

    let isDragging = false, offsetX, offsetY;
    const header = document.getElementById('snakeHeader');
    header.addEventListener('mousedown', (e) => {
      isDragging = true;
      offsetX = e.clientX - snakeWindow.offsetLeft;
      offsetY = e.clientY - snakeWindow.offsetTop;
    });
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        snakeWindow.style.left = e.clientX - offsetX + 'px';
        snakeWindow.style.top = e.clientY - offsetY + 'px';
      }
    });
    document.addEventListener('mouseup', () => isDragging = false);

    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 10;
    let snake = [{ x: 150, y: 150 }];
    let direction = 'RIGHT';
    let food = { x: 100, y: 100 };
    let paused = false;

    function drawRect(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, gridSize, gridSize);
    }

    function moveSnake() {
      if (paused) return;

      const head = { ...snake[0] };
      if (direction === 'RIGHT') head.x += gridSize;
      else if (direction === 'LEFT') head.x -= gridSize;
      else if (direction === 'UP') head.y -= gridSize;
      else if (direction === 'DOWN') head.y += gridSize;
      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        placeFood();
      } else {
        snake.pop();
      }

      if (
        head.x < 0 || head.x >= canvas.width ||
        head.y < 0 || head.y >= canvas.height ||
        snake.slice(1).some(p => p.x === head.x && p.y === head.y)
      ) {
        alert("Game Over!");
        clearInterval(game);
        snakeWindow.remove();
      }
    }

    function placeFood() {
      food = {
        x: Math.floor(Math.random() * (canvas.width / gridSize)) * gridSize,
        y: Math.floor(Math.random() * (canvas.height / gridSize)) * gridSize,
      };
    }

    function draw() {
      if (paused) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      snake.forEach(s => drawRect(s.x, s.y, 'lime'));
      drawRect(food.x, food.y, 'red');
    }

    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (key === 'w' && direction !== 'DOWN') direction = 'UP';
      if (key === 's' && direction !== 'UP') direction = 'DOWN';
      if (key === 'a' && direction !== 'RIGHT') direction = 'LEFT';
      if (key === 'd' && direction !== 'LEFT') direction = 'RIGHT';
      if (e.code === 'Space') {
        paused = !paused;
      }
    });

    const game = setInterval(() => {
      moveSnake();
      draw();
    }, 100);
  };
})();
(function () {
  const tetrisBtn = document.getElementById('menuBtn2');
  if (!tetrisBtn) {
    console.error("Knop 'menuBtn2' niet gevonden.");
    return;
  }

  tetrisBtn.addEventListener('click', () => {
    if (document.getElementById('tetrisWindow')) return;

    // Maak een versleepbaar venster
    const win = document.createElement('div');
    win.id = 'tetrisWindow';
    win.style.cssText = `
      position: fixed;
      top: 120px;
      left: 120px;
      width: 350px;
      background: #111;
      color: white;
      border: 2px solid #333;
      border-radius: 8px;
      z-index: 10000;
      font-family: sans-serif;
    `;

    win.innerHTML = `
      <div id="tetrisHeader" style="padding: 10px; background: #222; cursor: move;">
        <strong>Tetris</strong>
        <button id="closeTetris" style="float:right; background:#900; color:white; border:none; border-radius:4px; padding:2px 6px; cursor:pointer;">X</button>
      </div>
      <div id="tetrisGame" style="padding: 10px; text-align: center;">
        <div id="startScreen">
          <h2 style="margin:10px 0;">TETRIS</h2>
          <button id="playTetris" style="padding: 10px 20px; font-size: 16px;">Play</button>
        </div>
        <canvas id="tetrisCanvas" width="200" height="400" style="display:none; background:black; border:2px solid #555;"></canvas>
        <div id="gameOverText" style="display:none; color:red; margin-top:10px; font-weight:bold;"></div>
      </div>
    `;
    document.body.appendChild(win);

    // Sleepfunctionaliteit
    let isDragging = false, offsetX, offsetY;
    const header = document.getElementById('tetrisHeader');
    header.addEventListener('mousedown', function (e) {
      isDragging = true;
      offsetX = e.clientX - win.offsetLeft;
      offsetY = e.clientY - win.offsetTop;
    });
    document.addEventListener('mousemove', function (e) {
      if (isDragging) {
        win.style.left = e.clientX - offsetX + 'px';
        win.style.top = e.clientY - offsetY + 'px';
      }
    });
    document.addEventListener('mouseup', function () {
      isDragging = false;
    });

    // Sluitknop
    document.getElementById('closeTetris').onclick = () => {
      clearInterval(gameInterval);
      win.remove();
    };

    const canvas = document.getElementById('tetrisCanvas');
    const ctx = canvas.getContext('2d');
    const playBtn = document.getElementById('playTetris');
    const startScreen = document.getElementById('startScreen');
    const gameOverText = document.getElementById('gameOverText');

    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 20;

    let board = [];
    let current;
    let gameInterval;

    const colors = ['cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];
    const tetrominoes = [
      [[1, 1, 1, 1]], // I
      [[1, 0, 0], [1, 1, 1]], // J
      [[0, 0, 1], [1, 1, 1]], // L
      [[1, 1], [1, 1]], // O
      [[0, 1, 1], [1, 1, 0]], // S
      [[0, 1, 0], [1, 1, 1]], // T
      [[1, 1, 0], [0, 1, 1]] // Z
    ];

    function resetBoard() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) {
            drawCell(x, y, colors[board[y][x] - 1]);
          }
        }
      }
      if (current) {
        for (let y = 0; y < current.shape.length; y++) {
          for (let x = 0; x < current.shape[y].length; x++) {
            if (current.shape[y][x]) {
              drawCell(current.x + x, current.y + y, colors[current.type]);
            }
          }
        }
      }
    }

    function collide(x, y, shape) {
      for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
          if (
            shape[row][col] &&
            (board[y + row] && board[y + row][x + col]) !== 0
          ) {
            return true;
          }
        }
      }
      return false;
    }

    function merge() {
      current.shape.forEach((row, y) => {
        row.forEach((val, x) => {
          if (val) board[current.y + y][current.x + x] = current.type + 1;
        });
      });
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
    }

    function drop() {
      current.y++;
      if (collide(current.x, current.y, current.shape)) {
        current.y--;
        merge();
        clearRows();
        spawn();
        if (collide(current.x, current.y, current.shape)) {
          gameOver();
        }
      }
      drawBoard();
    }

    function clearRows() {
      board = board.filter(row => row.some(cell => !cell));
      while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
    }

    function spawn() {
      const type = Math.floor(Math.random() * tetrominoes.length);
      current = {
        x: Math.floor(COLS / 2) - 2,
        y: 0,
        shape: tetrominoes[type],
        type
      };
    }

    function gameOver() {
      clearInterval(gameInterval);
      gameOverText.style.display = 'block';
      gameOverText.innerText = `GAME OVER`;
      setTimeout(() => {
        gameOverText.style.display = 'none';
        canvas.style.display = 'none';
        startScreen.style.display = 'block';
      }, 3000);
    }

    document.addEventListener('keydown', e => {
      if (!current) return;
      const key = e.key.toLowerCase();
      if ((key === 'arrowleft' || key === 'a') && !collide(current.x - 1, current.y, current.shape)) current.x--;
      if ((key === 'arrowright' || key === 'd') && !collide(current.x + 1, current.y, current.shape)) current.x++;
      if (key === 'arrowdown' || key === 's') drop();
      if (key === 'arrowup' || key === 'w') {
        const rotated = rotate(current.shape);
        if (!collide(current.x, current.y, rotated)) current.shape = rotated;
      }
      drawBoard();
    });

    playBtn.addEventListener('click', () => {
      resetBoard();
      spawn();
      startScreen.style.display = 'none';
      canvas.style.display = 'block';
      gameInterval = setInterval(drop, 400); // Snellere val
    });
  });
})();
